---
slug: 51
title: "Spring 05"
authors: seokjae
tags: ["tistory"]
enableComments: true
keywords: ["tistory"]
date: 2021-02-14T15:14:09+09:00
---

> 원문: https://doljae.tistory.com/51

## Logging

 [\[Logging\] SLF4J를 이용한 Logging - Heee's Development Blog

Step by step goes a long way.

<!-- truncate -->

gmlwjd9405.github.io](https://gmlwjd9405.github.io/2019/01/04/logging-with-slf4j.html)

 [\[Java Library\] slf4j + log4j2 한 방 정리

| slf4j와 log4j2 slf4j는 자바 로깅 시스템을 쉽게 사용할 수 있도록 해주는 라이브러리이며, 다양한 자바 로깅 시스템을 사용할 수 있도록 파사드 패턴(facade pattern) 및 추상화를 통해 로깅 기능을 제

engkimbs.tistory.com](https://engkimbs.tistory.com/861)

Spring Boot의 Logging 기본 인터페이스는 slf4j를 사용하고 있다.

Spring Boot의 Logging 기본 구현체는 Logback이다.

log4j2는 slf4j의 구현체 중 하나로 Logback 보다 여러 가지 면에서 보완되었다고 한다.

보통 log4j2를 많이 사용하는 것 같다.

### Logging Level

 [log4j - Logging Levels - Tutorialspoint

log4j - Logging Levels The org.apache.log4j.Level levels. You can also define your custom levels by sub-classing the Level class. Level Description ALL All levels including custom levels. DEBUG Designates fine-grained informational events that are most use

www.tutorialspoint.com](https://www.tutorialspoint.com/log4j/log4j_logging_levels.htm)

&lt;table style="border-collapse: collapse; width: 100%; height: 173px;" border="1" data-ke-style="style2"&gt;&lt;tbody&gt;&lt;tr style="height: 20px;"&gt;&lt;td style="width: 10.5814%; height: 20px;"&gt;레벨&lt;/td&gt;&lt;td style="width: 89.4186%; height: 20px;"&gt;설명&lt;/td&gt;&lt;/tr&gt;&lt;tr style="height: 20px;"&gt;&lt;td style="width: 10.5814%; height: 20px;"&gt;ALL&lt;/td&gt;&lt;td style="width: 89.4186%; height: 20px;"&gt;&lt;span&gt;All levels including custom levels.&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr style="height: 20px;"&gt;&lt;td style="width: 10.5814%; height: 20px;"&gt;TRACE&lt;/td&gt;&lt;td style="width: 89.4186%; height: 20px;"&gt;&lt;span&gt;Designates finer-grained informational events than the DEBUG.&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr style="height: 20px;"&gt;&lt;td style="width: 10.5814%; height: 20px;"&gt;DEBUG&lt;/td&gt;&lt;td style="width: 89.4186%; height: 20px;"&gt;&lt;span&gt;Designates fine-grained informational events that are most useful to debug an application.&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr style="height: 13px;"&gt;&lt;td style="width: 10.5814%; height: 13px;"&gt;INFO&lt;/td&gt;&lt;td style="width: 89.4186%; height: 13px;"&gt;&lt;span&gt;Designates informational messages that highlight the progress of the application at coarse-grained level.&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr style="height: 20px;"&gt;&lt;td style="width: 10.5814%; height: 20px;"&gt;WARN&lt;/td&gt;&lt;td style="width: 89.4186%; height: 20px;"&gt;&lt;span&gt;Designates potentially harmful situations.&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr style="height: 20px;"&gt;&lt;td style="width: 10.5814%; height: 20px;"&gt;ERROR&lt;/td&gt;&lt;td style="width: 89.4186%; height: 20px;"&gt;&lt;span&gt;Designates error events that might still allow the application to continue running.&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr style="height: 20px;"&gt;&lt;td style="width: 10.5814%; height: 20px;"&gt;FATAL&lt;/td&gt;&lt;td style="width: 89.4186%; height: 20px;"&gt;&lt;span&gt;Designates very severe error events that will presumably lead the application to abort.&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr style="height: 20px;"&gt;&lt;td style="width: 10.5814%; height: 20px;"&gt;OFF&lt;/td&gt;&lt;td style="width: 89.4186%; height: 20px;"&gt;&lt;span&gt;The highest possible rank and is intended to turn off logging.&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

코드의 용도에 따라서 로깅 레벨을 다르게 해서 로그를 관리하면, 유지 보수에 용이하고 문제가 발생했을 때 빠르게 해당 지점을 찾을 수 있다는 장점이 있다.

레벨이 낮을수록 하위 레벨의 로그를 함께 출력한다. 그러니깐 ALL 레벨은 모든 레벨의 로그가 뜨고, OFF는 프로그램이 아예 종료될 때의 로그만 뜬다.

### GetMapping을 쓸 때 결과와 오류 메시지(만약 있다면)를 동시에 보내는 방법

 [Using Spring ResponseEntity to Manipulate the HTTP Response | Baeldung

Learn how to manipulate the HTTP response using the ResponseEntity class.

www.baeldung.com](https://www.baeldung.com/spring-response-entity)

ResponseEntity를 사용한다.

```
// ResponseEntity를 이용해서 데이터와 status코드를 반환하는 방법
	@GetMapping("/{id}")
	public ResponseEntity<?> getTodo(@PathVariable("id") Long id) {
		TodoVo todo = service.getTodo(id);
		if (todo == null)
			return new ResponseEntity<>("Todo Not Found", HttpStatus.NOT_FOUND);
		return ResponseEntity.status(HttpStatus.OK).body(todo);
	}

	@PostMapping("")
	public ResponseEntity<?> registerTodo(@RequestBody TodoVo todo) {
		int cnt = service.registerTodo(todo);
		if (cnt == 1)
			return ResponseEntity.status(HttpStatus.OK).body(service.getTodoList());
		//500 에러
		return new ResponseEntity<>("Todo Not Found", HttpStatus.INTERNAL_SERVER_ERROR);
	}
```

일반적으로 ModelAndView로 데이터와 화면단을 같이 넘기거나, REST API의 경우 해당하는 결과를 객체로 반환하면 json형태로 받을 수 있게 만드는 게 아주 기초적인 구현이다.

ResponseEntity를 사용하면 RestController에서 데이터를 반환하는 것과 비슷한데, HTTP 상태, 메시지 등을 커스텀해서 보낼 수 있다는 차이점이 있다. 예를 들어 잘못된 요청을 보냈을 때 HTTP상태 메시지를 404로 설정하고, 빈 body를 반환하는 것이 가능하다.

즉 데이터뿐만 아니라 HTTP 상태 코드 및 메시지까지 직접 제어를 해야 할 경우에는 ResponseEntity를 사용하는 것이 올바르다.

### Synchronized vs Concurrent

 [SynchronizedMap과 ConcurrentHashMap

지금까지 대부분 포스팅은 실무위주로 사용 예를 들면서 많이 썼었는데, 이번 포스팅은 조금 개념 위주로 작성하였습니다. SynchronizedMap과 ConcurrentHashMap 개념에 대해서 설명합니다. 회사 일하

ooz.co.kr](https://ooz.co.kr/71)

요약하면 동기화가 필요한 곳에만 동기화를 해야 한다. 동기화는 매우 비싼 작업이기 때문이다.

HashTable은 기본적으로 동기화를 보장하는 자료구조이다. 그래서 코딩 테스트에는 이것을 보장하지 않지만 처리 속도가 상대적으로 빠르고 가벼운 HashMap을 사용한다.

만일 동기화가 필요하다면, JAVA 1.5 버전부터 제공하는 ConcurrentUtil이라는 인터페이스에서 제공하는 ConcurrentHashMap을 사용하면 된다. HashTable에 비해서 Map의 필요한 부분에만 락을 걸기 때문에 속도도 빠르면서 동기화 작업을 수행할 수 있다.
