---
slug: 72
title: "310. Minimum Height Trees"
authors: seokjae
tags: ["tistory"]
enableComments: true
keywords: ["tistory"]
date: 2021-04-08T14:57:47+09:00
---

> 원문: https://doljae.tistory.com/72

[Minimum Height Trees - LeetCode

Level up your coding skills and quickly land a job. This is the best place to expand your knowledge and get prepared for your next interview.

leetcode.com](https://leetcode.com/problems/minimum-height-trees/)

<!-- truncate -->

### 1\. Brute Force DFS (시간 초과)

```
from typing import *
from collections import defaultdict

class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        graph = defaultdict(set)
        for edge in edges:
            src, dsc = edge
            graph[src].add(dsc)
            graph[dsc].add(src)

        def sol(cur, graph, visited):
            visited[cur] = 1
            res, flag = 0, 0
            for adj in graph[cur]:
                if not visited[adj]:
                    flag = 1
                    res = max(sol(adj, graph, visited), res)
            if not flag:
                return 1
            return res + 1

        min_height, answer = float("inf"), [0]
        for node in graph:
            temp = sol(node, graph, [0] * n)
            if temp < min_height:
                min_height = temp
                answer = [node]
            elif temp == min_height:
                answer.append(node)
        return answer
```

![](https://blog.kakaocdn.net/dna/bwcL3E/btq2aFNGcVg/AAAAAAAAAAAAAAAAAAAAAKxmDqTd-ds0OfOxSUVnBVhnchseThmnuikduYR-kIDo/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=KMQok4XQ%2B21RvUTQSwheWk9uA%2FQ%3D)

### 2\. Topological Sort (위상 정렬) 응용

```
from typing import *
from collections import defaultdict, deque

class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if len(edges) == 1:
            return edges[0]

        graph = defaultdict(set)
        indegree = [0] * n
        for edge in edges:
            src, dsc = edge
            graph[src].add(dsc)
            graph[dsc].add(src)
            indegree[src] += 1
            indegree[dsc] += 1
        q = deque([])
        for node in graph:
            if indegree[node] == 1:
                q.append(node)
        left_node_num = n
        answer = [0]
        while left_node_num > 2:
            deleted_node, candi_node = [], []
            while q:
                cur = q.popleft()
                deleted_node.append(cur)
                for adj in graph[cur]:
                    graph[adj].remove(cur)
                    indegree[adj] -= 1
                    if indegree[adj] == 1:
                        candi_node.append(adj)
            left_node_num -= len(deleted_node)
            q = deque(candi_node)
            answer = candi_node
        return answer
```

![](https://blog.kakaocdn.net/dna/bAolnd/btq16tnaNzT/AAAAAAAAAAAAAAAAAAAAAAcj4vjuy2tYCTteBP_D_w9JRHhMg4JisLLYDEQhRwcT/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=o%2FR323eUM3cezpQMXBIh107p%2Fd4%3D)

### 3\. Tree DP 

추후 기술
